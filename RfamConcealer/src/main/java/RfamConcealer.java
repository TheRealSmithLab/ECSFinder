import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class RfamConcealer {

    private String outPath = "./rfam_subset.fa";
    private File clustal = new File(outPath, "ClustalFiles");
    private String dbPath = "./input/"; // This will be updated with -rfam argument
    private String mafSourcePath = "./maf_input/";  // This will be updated with -maf argument
    private File outFile = new File(outPath);
    private File mafFolder = new File(outPath, "Maf_folder");

    private boolean verbose = false;

    private int minPerFam = 2;
    private int maxPerFam = 20;
    private int totalSeqs = 200;
    private int minPi = 10;
    private int maxPi = 80;

    public static void main(String[] args) throws IOException, InterruptedException {
        RfamConcealer generator = new RfamConcealer();
        generator.run(args);
    }

    private void run(String[] args) throws IOException, InterruptedException {
        if (args.length == 0) {
            printUsage();
            return;
        }

        parseArguments(args);

        // Validate that both rfam and maf paths are provided
        if (dbPath == null || mafSourcePath == null) {
            System.err.println("Both -rfam and -maf paths are required.");
            printUsage();
            return;
        }

        // Initialize the classes responsible for different parts of the project
        File[] rfamfolder = new File(dbPath).listFiles();
        if (rfamfolder == null) {
            System.err.println("No files found in the specified RFAM directory.");
            return;
        }
        File mafSourceFolder = new File(mafSourcePath);

        DataLoader dataLoader = new DataLoader(mafFolder, rfamfolder, mafSourceFolder, minPerFam);
        dataLoader.processFastaFiles(rfamfolder, verbose);

        Map<String, List<String>> preparedData = new HashMap<>();

        for (Map.Entry<String, List<String[]>> entry : dataLoader.sequenceNames.entrySet()) {
            String rfamId = entry.getKey();
            List<String[]> sequencesAndNames = entry.getValue();

            if (verbose) {
                System.out.println("Processing RFAM ID: " + rfamId + ", with " + sequencesAndNames.size() + " sequences");
            }
            preparedData.put(rfamId, sequencesAndNames.stream().map(arr -> arr[0]).collect(Collectors.toList()));
        }
        preparedData.forEach((rfamId, sequences) -> {
            if (verbose) {
                System.out.println("Prepared " + sequences.size() + " sequences for RFAM ID: " + rfamId);
            }
        });

        SequenceSampler sampler = new SequenceSampler(minPerFam, maxPerFam, minPi, maxPi, totalSeqs, verbose);
        Map<String, List<String[]>> sampledSequences = sampler.sampleSequences(dataLoader.sequenceNames);

        dataLoader.processMafFiles(sampledSequences, outFile, verbose);

        File gaplessFolder = new File(mafFolder, "gapless");
        File[] gaplessFiles = gaplessFolder.listFiles();
        if (gaplessFiles != null) {
            File mafOutputFile = new File(outPath + "/output.maf");
            try (BufferedWriter maf_species = new BufferedWriter(new FileWriter(mafOutputFile))) {
                maf_species.write("##maf version=1 scoring=none" + "\n" + "# generated by Vanda" + "\n" + "\n" + "\n");

                for (File gaplessFile : gaplessFiles) {
                    Map<String, String> alignedSequences = realignSequences(gaplessFile.getAbsolutePath());
                    maf_species.write("a score=0.00\n");

                    for (Map.Entry<String, String> entry : alignedSequences.entrySet()) {
                        int strip_maf = entry.getValue().replace("-", "").length();
                        maf_species.write("s\t" + entry.getKey() + "\t" +
                                "0\t" + strip_maf + "\t" + "+\t" + "198295559\t" + entry.getValue() + "\n");
                    }

                    maf_species.write("\n\n");
                }
            }
        }

        generateClustalFiles(sampledSequences, clustal);
    }

    private void printUsage() {
        System.out.println("\n***************************************************************************************\n" +
                "*** RfamConcealer\n" +
                "*** Selects random (sub)sequences from a reference database\n\n" +
                "Usage: java RfamConcealer [options] -rfam [path to RFAM directory] -maf [path to MAF directory]\n" +
                "Options:\n" +
                "  -v            \tVerbose output\n" +
                "  -min_pi (int) \tMinimum pairwise identity percentage (default 10)\n" +
                "  -max_pi (int) \tMaximum pairwise identity percentage (default 80)\n" +
                "  -max_f (int)  \tMaximum sequences per RFAM family/input file (default 20)\n" +
                "  -min_f (int)  \tMinimum sequences per RFAM family/input file (default 2)\n" +
                "  -t (int)      \tMaximum total sequences to include (default 250)\n" +
                "  -o (string)   \tWrite sampled sequences to file (default ./rfam_subset.fa)\n");
    }

    private void parseArguments(String[] args) {
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "-min_pi":
                    minPi = Integer.parseInt(args[++i]);
                    break;
                case "-max_pi":
                    maxPi = Integer.parseInt(args[++i]);
                    break;
                case "-max_f":
                    maxPerFam = Integer.parseInt(args[++i]);
                    break;
                case "-min_f":
                    minPerFam = Integer.parseInt(args[++i]);
                    break;
                case "-t":
                    totalSeqs = Integer.parseInt(args[++i]);
                    break;
                case "-o":
                    updateOutputPath(args[++i]);
                    break;
                case "-v":
                    verbose = true;
                    break;
                case "-rfam":
                    dbPath = args[++i];
                    break;
                case "-maf":
                    mafSourcePath = args[++i];
                    break;
                default:
                    System.out.println("Unrecognized argument: " + args[i]);
                    printUsage();
                    System.exit(1);
            }
        }
    }

    private void updateOutputPath(String path) {
        outPath = path;
        outFile = new File(outPath);
        mafFolder = new File(outPath, "Maf_folder");
        clustal = new File(outPath, "ClustalFiles");
        if (!outFile.exists()) {
            boolean created = outFile.mkdirs();
            if (!created) {
                System.err.println("Failed to create output directory: " + outPath);
            }
        }
        if (!mafFolder.exists() && !mafFolder.mkdirs()) {
            System.err.println("Failed to create MAF folder within output directory.");
        }
    }

    public static Map<String, String> realignSequences(String nameOfFile) throws IOException, InterruptedException {
        Map<String, String> mafftRealigned = new HashMap<>();
        List<String> command = new ArrayList<>();

        Path mafftBinaryPath = Files.walk(Paths.get("/home/vandalovejoy/bin/"), 1)
                .filter(Files::isExecutable)
                .filter(p -> p.getFileName().toString().equals("mafft-ginsi"))
                .findFirst()
                .orElseThrow(() -> new IOException("MAFFT binary not found."));

        command.add(mafftBinaryPath.toString());
        command.add("--quiet");
        command.add("--thread");
        command.add("-5");

        command.add(nameOfFile);

        ProcessBuilder pb = new ProcessBuilder(command);
        Process mafftProcess = pb.start();

        try (BufferedReader reAligned = new BufferedReader(new InputStreamReader(mafftProcess.getInputStream()))) {
            StringBuilder sequence = new StringBuilder();
            String speciesReal = "";
            String line;

            while ((line = reAligned.readLine()) != null) {
                if (line.startsWith(">")) {
                    if (!speciesReal.isEmpty()) {
                        mafftRealigned.put(speciesReal, sequence.toString().toUpperCase());
                        sequence = new StringBuilder();
                    }
                    speciesReal = line.substring(1);
                } else {
                    sequence.append(line);
                }
            }

            if (!speciesReal.isEmpty()) {
                mafftRealigned.put(speciesReal, sequence.toString().toUpperCase());
            }
        }

        int exitCode = mafftProcess.waitFor();
        if (exitCode != 0) {
            throw new IOException("MAFFT exited with error code: " + exitCode);
        }

        return mafftRealigned;
    }

    public static void generateClustalFiles(Map<String, List<String[]>> rfamFamilies, File clustal) throws IOException {
        Path outputPath = Paths.get(String.valueOf(clustal));
        if (!Files.exists(outputPath)) {
            Files.createDirectories(outputPath);
        }

        for (Map.Entry<String, List<String[]>> entry : rfamFamilies.entrySet()) {
            String rfamId = entry.getKey();
            List<String[]> sequences = entry.getValue();
            Path file = outputPath.resolve(rfamId + ".clustal");

            try (BufferedWriter writer = new BufferedWriter(new FileWriter(file.toFile()))) {
                writer.write("CLUSTAL W multiple sequence alignment\n\n");

                for (String[] sequenceData : sequences) {
                    String sequence = sequenceData[0].replace('U', 'T');
                    String sequenceName = sequenceData[1];
                    writer.write(sequenceName + "    " + sequence + "\n");
                }
            } catch (IOException e) {
                System.err.println("Failed to write Clustal file for RFam ID " + rfamId);
                e.printStackTrace();
            }
        }
    }
}
