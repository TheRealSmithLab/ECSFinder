)
# We will iterate over each predictor, calculate the ROC/AUC, and store results
individual_auc <- sapply(predictors, function(feature) {
# Build ROC object using that feature’s values as the “score”
roc_obj <- roc(response = mito_full$status, predictor = mito_full[[feature]])
auc(roc_obj)
})
# Optionally convert to a data.frame for easier inspection/printing
individual_auc_df <- data.frame(
Feature = names(individual_auc),
AUC = unname(individual_auc)
)
# Print the results
cat("\nIndividual Feature AUCs:\n")
print(individual_auc_df)
rf_thresh <- 0.403
mito_full <- mito_full %>%
mutate(
pred_rf = ifelse(rf_probs >= rf_thresh, "TP", "FP")
)
library(pROC)
roc_sci <- roc(
response  = mito_full$status,  # Factor: levels=c("FP","TP")
predictor = mito_full$sci
)
sci_thresh_val <- as.numeric(best_sci["threshold"])
# ─────────────────────────────────────────────────────────────────────────────
# STEP 1: Add txt_file column
# ─────────────────────────────────────────────────────────────────────────────
rf_hits_403 <- rf_hits_403 %>%
mutate(txt_file = sub("\\.aln$", ".txt", name_file))
# ─────────────────────────────────────────────────────────────────────────────
# STEP 2: Read line 2 (seq_line) & line 3 (raw_struct), strip energy off line 3
# ─────────────────────────────────────────────────────────────────────────────
rf_hits_403 <- rf_hits_403 %>%
# 1) Read lines 2 & 3, strip the energy off line 3
mutate(
raw_23    = map(txt_file, ~ readLines(.x, n = 3, warn = FALSE)[2:3]),
seq_line  = map_chr(raw_23, 1),
raw_struct= map_chr(raw_23, 2),
# keep only the dot-bracket (up to first space)
secstruct = sub(" .*", "", raw_struct)
) %>%
select(-raw_23, -raw_struct) %>%
# 2) Split into char-vectors, drop any structure chars at “_” positions
mutate(
seq_vec    = map(seq_line,   ~ strsplit(.x, "")[[1]]),
struct_vec = map(secstruct,  ~ strsplit(.x, "")[[1]]),
# filter out gaps
secstruct  = map2_chr(struct_vec, seq_vec, ~ {
v <- .x[.y != "_"]
paste0(v, collapse = "")
})
) %>%
select(-seq_line, -seq_vec, -struct_vec) %>%
# 3) Encode to 1/0
mutate(
struct01 = str_replace_all(secstruct, "[()]", "1") %>%
str_replace_all("\\.",   "0")
) %>%
# 4) Expand to per-base calls on the “+” strand
filter(eleventh == "+") %>%
mutate(
start       = as.integer(second),
end         = as.integer(third),
pos_list    = map2(start, struct01, ~ seq(.x, .x + nchar(.y) - 1)),
paired_list = map(struct01,  ~ as.integer(strsplit(.x, "")[[1]] == "1"))
) %>%
# drop any windows where lengths disagree
filter(map2_lgl(pos_list, paired_list, ~ length(.x) == length(.y))) %>%
unnest(cols = c(pos_list, paired_list)) %>%
transmute(
seqname = second,
pos      = pos_list,
paired   = paired_list
) -> expanded_calls
# 5) Majority‐vote per base
consensus_plus <- expanded_calls %>%
group_by(seqname, pos) %>%
summarise(
n_windows       = n(),
paired_votes    = sum(paired),
majority_paired = paired_votes > n_windows/2,
.groups         = "drop"
)
# Single “chromosome” named “Mito” from 1 to 16568
mito_length <- 16568
df_chr <- data.frame(start = 1, end = mito_length)
rownames(df_chr) <- "Mito"
line_plus <- consensus_plus %>%
filter(seqname == "Mito") %>%           # if you used seqname="Mito"
select(pos, majority_paired) %>%
mutate(signal = as.integer(majority_paired))
# ─────────────────────────────────────────────────────────────────────────────
# 3) Hit‐windows on + strand
# ─────────────────────────────────────────────────────────────────────────────
blocks_plus <- rf_hits_403 %>%
filter(eleventh == "+") %>%             # + strand only
transmute(
chr   = "Mito",
start = as.integer(second),
end   = as.integer(third)
)
library(caret)
library(pROC)
library(dplyr)
mito<- read.csv("/home/vandalovejoy/projects/computecanada/ECSFinder/MT/final.csv")
TP_mito <- read.csv("/home/vandalovejoy/projects/computecanada/ECSFinder/MT/TP.tsv",
sep = "\t", header = FALSE)
# 2) Extract the join‐keys from mito$name_file
parts <- strsplit(mito$name_file, "_|\\.aln")
mito <- mito %>%
mutate(
second   = as.character(sapply(parts, `[`, 2)),
third    = as.character(sapply(parts, `[`, 3)),
eleventh = as.character(sapply(parts, `[`, 11)),
ten = as.character(sapply(parts, `[`, 10))
)
TP_sub <- TP_mito %>%
dplyr::select(V2, V3, V6, V5, V4) %>%    # <- force dplyr’s select()
dplyr::rename(
second   = V2,
third    = V3,
eleventh = V6,
ten      = V5,
status   = V4
) %>%
dplyr::mutate(
dplyr::across(c(second, third, eleventh, ten), as.character)
)
# 4) Left‐join and then fill unmatched with "FP"
mito_full <- mito %>%
left_join(TP_sub, by = c("second","third","eleventh", "ten")) %>%
mutate(status = coalesce(status, "FP"))
library(pROC)
library(purrr)   # for map_dfr()
library(dplyr)
# make sure `ten` is numeric
mito_full <- mito_full %>%
mutate(ten = as.numeric(ten))
# Convert 'status' to a factor with levels c("FP", "TP")
mito_full$status <- factor(mito_full$status, levels = c("FP", "TP"))
# 3) Define the same predictors you used when training the model
predictors <- c(
"min_energy",
"pseudo_energy",
"log_min_evalue",
"covarying_bp",
"MPI",
"average_MFE_sample",
"sd_sample",
"zscore",
"sci"
)
# 4) Load your saved random forest model
final_rf <- readRDS("/home/vandalovejoy/projects/rfam_ecsfinder_output_new/final_rf_model.rds")
# Identify features
feature_cols <- setdiff(names(mito_full), "status")
rf_probs <- predict(
final_rf,
newdata = mito_full %>% select(all_of(feature_cols)),
type    = "prob"
)[, "TP"]
roc_rf <- roc(response = mito_full$status, predictor = rf_probs)
auc_rf <- auc(roc_rf)
cat("Random Forest AUC:", auc_rf, "\n")
# --- 2) AUC for each individual predictor ---
predictors <- c(
"min_energy",
"pseudo_energy",
"log_min_evalue",
"covarying_bp",
"MPI",
"average_MFE_sample",
"sd_sample",
"zscore",
"sci"
)
# We will iterate over each predictor, calculate the ROC/AUC, and store results
individual_auc <- sapply(predictors, function(feature) {
# Build ROC object using that feature’s values as the “score”
roc_obj <- roc(response = mito_full$status, predictor = mito_full[[feature]])
auc(roc_obj)
})
# Optionally convert to a data.frame for easier inspection/printing
individual_auc_df <- data.frame(
Feature = names(individual_auc),
AUC = unname(individual_auc)
)
# Print the results
cat("\nIndividual Feature AUCs:\n")
print(individual_auc_df)
rf_thresh <- 0.403
mito_full <- mito_full %>%
mutate(
pred_rf = ifelse(rf_probs >= rf_thresh, "TP", "FP")
)
library(pROC)
roc_sci <- roc(
response  = mito_full$status,  # Factor: levels=c("FP","TP")
predictor = mito_full$sci
)
sci_thresh_val <- as.numeric(best_sci["threshold"])
cat("Best sci threshold by Youden’s J:", sci_thresh_val, "\n")
mito_full <- mito_full %>%
mutate(
pred_sci = ifelse(sci >= sci_thresh_val, "TP", "FP")
)
rf_fp_but_not_sciTP <- mito_full %>%
filter(
status  == "FP",
pred_rf == "TP",
pred_sci == "FP"
)
nrow(rf_fp_but_not_sciTP)
head(rf_fp_but_not_sciTP)
mito_full <- mito_full %>%
mutate(rf_prob_TP = rf_probs)
mito_full <- mito_full %>%
mutate(rf_prob_TP = rf_probs) %>%
mutate(pred_rf = ifelse(rf_prob_TP >= 0.403, "TP", "FP"))
rf_hits_403 <- mito_full %>%
filter(pred_rf == "TP")
rf_hits_403 <- mito_full[rf_probs >= 0.403, ]
rf_hits_403 %>%
select(second, third, ten, eleventh)
rf_hits_403 <- rf_hits_403 %>%
mutate(
info_string = paste0(
"chrM ", second," ", third, " 0  ", rf_prob_TP*1000, " ",eleventh
)
)
cat(rf_hits_403$info_string, sep = "\n")
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
library(readr)
library(ggplot2)
library(pheatmap)
setwd("~/projects/computecanada/ECSFinder/MT/aln")
# ─────────────────────────────────────────────────────────────────────────────
# STEP 1: Add txt_file column
# ─────────────────────────────────────────────────────────────────────────────
rf_hits_403 <- rf_hits_403 %>%
mutate(txt_file = sub("\\.aln$", ".txt", name_file))
raw_hits <- rf_hits_403
blocks_plus <- raw_hits %>%
filter(eleventh == "+") %>%
transmute(
chr   = "Mito",
start = as.integer(second),
end   = as.integer(third)
)
# ─────────────────────────────────────────────────────────────────────────────
# STEP 2: Read line 2 (seq_line) & line 3 (raw_struct), strip energy off line 3
# ─────────────────────────────────────────────────────────────────────────────
rf_hits_403 <- rf_hits_403 %>%
# 1) Read lines 2 & 3, strip the energy off line 3
mutate(
raw_23    = map(txt_file, ~ readLines(.x, n = 3, warn = FALSE)[2:3]),
seq_line  = map_chr(raw_23, 1),
raw_struct= map_chr(raw_23, 2),
# keep only the dot-bracket (up to first space)
secstruct = sub(" .*", "", raw_struct)
) %>%
select(-raw_23, -raw_struct) %>%
# 2) Split into char-vectors, drop any structure chars at “_” positions
mutate(
seq_vec    = map(seq_line,   ~ strsplit(.x, "")[[1]]),
struct_vec = map(secstruct,  ~ strsplit(.x, "")[[1]]),
# filter out gaps
secstruct  = map2_chr(struct_vec, seq_vec, ~ {
v <- .x[.y != "_"]
paste0(v, collapse = "")
})
) %>%
select(-seq_line, -seq_vec, -struct_vec) %>%
# 3) Encode to 1/0
mutate(
struct01 = str_replace_all(secstruct, "[()]", "1") %>%
str_replace_all("\\.",   "0")
) %>%
# 4) Expand to per-base calls on the “+” strand
filter(eleventh == "+") %>%
mutate(
start       = as.integer(second),
end         = as.integer(third),
pos_list    = map2(start, struct01, ~ seq(.x, .x + nchar(.y) - 1)),
paired_list = map(struct01,  ~ as.integer(strsplit(.x, "")[[1]] == "1"))
) %>%
# drop any windows where lengths disagree
filter(map2_lgl(pos_list, paired_list, ~ length(.x) == length(.y))) %>%
unnest(cols = c(pos_list, paired_list)) %>%
transmute(
seqname = second,
pos      = pos_list,
paired   = paired_list
) -> expanded_calls
# 5) Majority‐vote per base
consensus_plus <- expanded_calls %>%
group_by(seqname, pos) %>%
summarise(
n_windows       = n(),
paired_votes    = sum(paired),
majority_paired = paired_votes > n_windows/2,
.groups         = "drop"
)
# ─────────────────────────────────────────────────────────────────────────────
# STEP 7: Load WT1/WT2 heavy-strand reactivities (A/C only), shift by −1
# ─────────────────────────────────────────────────────────────────────────────
react_WT1 <- read_tsv(
"~/projects/mitochondria_shape/mitoDMS-repo/data/Reactivities/Whole_Genome/WT/1p/WT1_popavg_reacts_HeavyStrand.txt",
col_types = cols(
Position = col_integer(),
Mismatches = col_double(),
Base = col_character()
)
) %>%
filter(Base %in% c("A","C")) %>%
rename(pos = Position, react_WT1 = Mismatches) %>%
mutate(pos = pos )
react_WT2 <- read_tsv(
"~/projects/mitochondria_shape/mitoDMS-repo/data/Reactivities/Whole_Genome/WT/1p/WT2_popavg_reacts_HeavyStrand.txt",
col_types = cols(
Position = col_integer(),
Mismatches = col_double(),
Base = col_character()
)
) %>%
filter(Base %in% c("A","C")) %>%
rename(pos = Position, react_WT2 = Mismatches) %>%
mutate(pos = pos )
reactivity <- full_join(react_WT1, react_WT2, by = c("pos","Base")) %>%
mutate(react_mean = rowMeans(across(c(react_WT1, react_WT2)), na.rm = TRUE))
# ─────────────────────────────────────────────────────────────────────────────
# STEP 8: Merge structure consensus with reactivity
# ─────────────────────────────────────────────────────────────────────────────
combined_plus <- consensus_plus %>%
inner_join(reactivity, by = "pos")
library(pROC)
library(ggplot2)
# prepare 0/1 columns
combined_plus <- combined_plus %>%
mutate(
unpaired = as.integer(!majority_paired),
paired   = as.integer( majority_paired)
)
# ROC for unpaired
roc_un <- roc(
response  = combined_plus$unpaired,
predictor = combined_plus$react_mean,
quiet     = TRUE
)
# ROC for paired (invert the predictor)
roc_pa <- roc(
response  = combined_plus$paired,
predictor = -combined_plus$react_mean,
quiet     = TRUE
)
# Extract dataframes for ggplot
df_un <- data.frame(
fpr = 1 - roc_un$specificities,
tpr = roc_un$sensitivities,
class = "Unpaired"
)
df_pa <- data.frame(
fpr = 1 - roc_pa$specificities,
tpr = roc_pa$sensitivities,
class = "Paired"
)
roc_df <- bind_rows(df_un, df_pa)
# Plot both
ggplot(roc_df, aes(x = fpr, y = tpr, color = class)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray60") +
scale_color_manual(
values = c("Unpaired" = "darkorange", "Paired" = "steelblue")
) +
labs(
title = sprintf(
"ROC Curves: Reactivity → Unpaired (AUC=%.2f) and Paired (AUC=%.2f)",
auc(roc_un), auc(roc_pa)
),
x = "False Positive Rate",
y = "True Positive Rate",
color = "Predict\nPositive"
) +
theme_minimal(base_size = 14)
library(dplyr)
library(circlize)
# ─────────────────────────────────────────────────────────────────────────────
# 0) Prepare genome definition
# ─────────────────────────────────────────────────────────────────────────────
# Single “chromosome” named “Mito” from 1 to 16568
mito_length <- 16568
df_chr <- data.frame(start = 1, end = mito_length)
rownames(df_chr) <- "Mito"
# ─────────────────────────────────────────────────────────────────────────────
# 1) Reactivity: Sliding‐window signals
# ─────────────────────────────────────────────────────────────────────────────
# WT1_Pos_AC and WT1_Pos_GU should already exist
# with columns: Position (1..16568), DMS_Mean
# ─────────────────────────────────────────────────────────────────────────────
# 2) Consensus calls (0/1) per base on + strand
# ─────────────────────────────────────────────────────────────────────────────
line_plus <- consensus_plus %>%
filter(seqname == "Mito") %>%           # if you used seqname="Mito"
select(pos, majority_paired) %>%
mutate(signal = as.integer(majority_paired))
# ─────────────────────────────────────────────────────────────────────────────
# 3) Hit‐windows on + strand
# ─────────────────────────────────────────────────────────────────────────────
blocks_plus <- rf_hits_403 %>%
filter(eleventh == "+") %>%             # + strand only
transmute(
chr   = "Mito",
start = as.integer(second),
end   = as.integer(third)
)
library(dplyr)
library(circlize)
# ─────────────────────────────────────────────────────────────────────────────
# 0) Prepare genome definition
# ─────────────────────────────────────────────────────────────────────────────
# Single “chromosome” named “Mito” from 1 to 16568
mito_length <- 16568
df_chr <- data.frame(start = 1, end = mito_length)
rownames(df_chr) <- "Mito"
# ─────────────────────────────────────────────────────────────────────────────
# 1) Reactivity: Sliding‐window signals
# ─────────────────────────────────────────────────────────────────────────────
# WT1_Pos_AC and WT1_Pos_GU should already exist
# with columns: Position (1..16568), DMS_Mean
# ─────────────────────────────────────────────────────────────────────────────
# 2) Consensus calls (0/1) per base on + strand
# ─────────────────────────────────────────────────────────────────────────────
line_plus <- consensus_plus %>%
filter(seqname == "Mito") %>%           # if you used seqname="Mito"
select(pos, majority_paired) %>%
mutate(signal = as.integer(majority_paired))
# ─────────────────────────────────────────────────────────────────────────────
# 3) Hit‐windows on + strand
# ─────────────────────────────────────────────────────────────────────────────
blocks_plus <- raw_hits %>%
filter(eleventh == "+") %>%             # + strand only
transmute(
chr   = "Mito",
start = as.integer(second),
end   = as.integer(third)
)
circos.clear()
circos.par(
cell.padding = c(0,0,0,0),
track.margin = c(0.02, 0.02)
)
circos.initialize(factors = rownames(df_chr), xlim = df_chr)
circos.trackPlotRegion(
ylim = c(0, max(WT1_Pos_AC$DMS_Mean, WT1_Pos_GU$DMS_Mean)),
track.height = 0.15,
panel.fun = function(x, y) {
circos.yaxis(labels.cex = 0.4)
circos.lines(
WT1_Pos_AC$Position, WT1_Pos_AC$DMS_Mean,
col = "#8E28A4", lwd = 2
)
circos.lines(
WT1_Pos_GU$Position, WT1_Pos_GU$DMS_Mean,
col = "#C0D5F9", lwd = 2
)
}
)
# 0) load your sliding‐window helpers
source("~/projects/mitochondria_shape/mitoDMS-repo/code/functions.R")      # make sure DMS_React_Mean_Sliding() & Convert_Circos_Coords() are in scope
# 1) build a named list of your per‐base reactivities (you already read react_WT1 & react_WT2)
pos_avg.list <- list(WT1 = react_WT1, WT2 = react_WT2)
# 2) compute the 80‐nt sliding means for A/C (“true” DMS) and G/U (“noise”)
WT1_Pos_AC <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = TRUE,  GU = FALSE, window_size = 80)
WT1_Pos_GU <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = FALSE, GU = TRUE,  window_size = 80)
install.packages("ggmsa")
# 0) load your sliding‐window helpers
source("~/projects/mitochondria_shape/mitoDMS-repo/code/functions.R")      # make sure DMS_React_Mean_Sliding() & Convert_Circos_Coords() are in scope
# 1) build a named list of your per‐base reactivities (you already read react_WT1 & react_WT2)
pos_avg.list <- list(WT1 = react_WT1, WT2 = react_WT2)
# 2) compute the 80‐nt sliding means for A/C (“true” DMS) and G/U (“noise”)
WT1_Pos_AC <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = TRUE,  GU = FALSE, window_size = 80)
WT1_Pos_GU <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = FALSE, GU = TRUE,  window_size = 80)
# 0) load your sliding‐window helpers
source("~/projects/mitochondria_shape/mitoDMS-repo/code/functions.R")      # make sure DMS_React_Mean_Sliding() & Convert_Circos_Coords() are in scope
# 1) build a named list of your per‐base reactivities (you already read react_WT1 & react_WT2)
pos_avg.list <- list(WT1 = react_WT1, WT2 = react_WT2)
# 2) compute the 80‐nt sliding means for A/C (“true” DMS) and G/U (“noise”)
WT1_Pos_AC <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = TRUE,  GU = FALSE, window_size = 80)
WT1_Pos_GU <- DMS_React_Mean_Sliding(pos_avg.list$WT1, AC = FALSE, GU = TRUE,  window_size = 80)
# 3) convert to 1–16 568 coords for circos
WT1_Pos_AC <- Convert_Circos_Coords(WT1_Pos_AC)
WT1_Pos_GU <- Convert_Circos_Coords(WT1_Pos_GU)
# 0) load your sliding‐window helpers
source("~/projects/mitochondria_shape/mitoDMS-repo/code/functions.R")      # make sure DMS_React_Mean_Sliding() & Convert_Circos_Coords() are in scope
install.packages("ggmsa")
# 0) load your sliding‐window helpers
source("~/projects/mitochondria_shape/mitoDMS-repo/code/functions.R")      # make sure DMS_React_Mean_Sliding() & Convert_Circos_Coords() are in scope
BiocManager::install("ggmsa")
# install ggalt (from CRAN) now that proj4 is available
install.packages("ggalt")
# then install ggmsa from Bioconductor
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("ggmsa")
install.packages("proj4")  # which should succeed now
install.packages("ggalt")  # requires proj4
install.packages("ggmsa")  # requires ggalt
