import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class RFAM_project {

    private String outPath = "./rfam_subset.fa";
    private  File clustal = new File(outPath, "ClustalFiles");
    private String dbPath = "./input/";
    private File outFile = new File(outPath);
    private File mafFolder = new File(outPath, "Maf_folder");

    private boolean verbose = false;

    private int minPerFam = 2;
    private int maxPerFam = 20;
    private int totalSeqs = 200;
    private int minPi = 10;
    private int maxPi = 80;


    public static void main(String[] args) throws IOException, InterruptedException {
        RFAM_project generator = new RFAM_project();
        generator.run(args);
    }

    private void run(String[] args) throws IOException, InterruptedException {
        if (args.length == 0) {
            printUsage();
            return;
        }

        parseArguments(args);
        // Initialize the classes responsible for different parts of the project
        File[] rfamfolder = new File(dbPath).listFiles();
        if (rfamfolder == null) {
            System.err.println("No files found in the specified directory.");
            return;
        }
        DataLoader dataLoader = new DataLoader(mafFolder, rfamfolder,minPerFam);
        dataLoader.processFastaFiles(rfamfolder, verbose);
        Map<String, List<String>> preparedData = new HashMap<>();

        for (Map.Entry<String, List<String[]>> entry : dataLoader.sequenceNames.entrySet()) {
            String rfamId = entry.getKey();
            List<String[]> sequencesAndNames = entry.getValue();

            if (verbose) {
                System.out.println("Processing RFAM ID: " + rfamId + ", with " + sequencesAndNames.size() + " sequences");
            }
            preparedData.put(rfamId, sequencesAndNames.stream().map(arr -> arr[0]).collect(Collectors.toList()));
        }
        preparedData.forEach((rfamId, sequences) -> {
            if (verbose) {
                System.out.println("Prepared " + sequences.size() + " sequences for RFAM ID: " + rfamId);
            }
        });
        // After loading and preparing your data into a suitable structure
        SequenceSampler sampler = new SequenceSampler(minPerFam, maxPerFam, minPi, maxPi,totalSeqs, verbose);
        // Adjust the variable to match the new return type of sampleSequences
        Map<String, List<String[]>> sampledSequences = sampler.sampleSequences( dataLoader.sequenceNames);
        dataLoader.processMafFiles(sampledSequences, outFile, verbose);
        // Process gapless folder after generating it previously
        File gaplessFolder = new File(mafFolder, "gapless");
        File[] gaplessFiles = gaplessFolder.listFiles();
        if (gaplessFiles != null) {
            File mafOutputFile = new File(outPath+"/output.maf");
            try (BufferedWriter maf_species = new BufferedWriter(new FileWriter(mafOutputFile))) {
                maf_species.write("##maf version=1 scoring=none"+"\n"+"# generated by Vanda"+"\n"+"\n"+"\n");

                for (File gaplessFile : gaplessFiles) { // Include all files
                    Map<String, String> alignedSequences = realignSequences(gaplessFile.getAbsolutePath());
                    maf_species.write("a score=0.00\n");
                    // Ensure you do not exceed the bounds of dataLoader.totalSequence
                    for (Map.Entry<String, String> entry : alignedSequences.entrySet()) { // Process all sequences
                        int strip_maf = entry.getValue().replace("-", "").length();
                        entry.getValue();
                        maf_species.write("s\t" + entry.getKey() + "\t" +
                                "0\t" + strip_maf + "\t" + "+\t" + "198295559\t" + entry.getValue() + "\n");

                    }

                    maf_species.write("\n\n");


                }
            }

        }

        generateClustalFiles(sampledSequences,clustal);

    }

    private void printUsage() {
        System.out.println("\n***************************************************************************************\n" +
                "*** GenerateRFAMsubsets\n" +
                "*** Selects random (sub)sequences from a reference database\n\n" +
                "Usage: java GenerateRFAMsubsets [options] -i [path to .fasta database folder]\n" +
                "\t*** INPUT folder must contain only fasta files***\n" +
                "Options:\n" +
                "  -v            \tVerbose output\n" +
                "  -min_pi (int) \tMinimum pairwise identity percentage (default 10)\n" +
                "  -max_pi (int) \tMaximum pairwise identity percentage (default 80)\n" +
                "  -max_f (int)  \tMaximum sequences per RFAM family/input file (default 20)\n" +
                "  -min_f (int)  \tMinimum sequences per RFAM family/input file (default 2)\n" +
                "  -t (int)      \tMaximum total sequences to include (default 250)\n" +
                "  -l            \tUse Needleman-Wunsch with free end gaps to calculate pairwise identity.\n" +
                "  -strip        \tStrip gaps in output\n" +
                "  -o (string)   \twrite sampled sequences to file (default ./rfam_subset.fa)\n");
    }

    private void parseArguments(String[] args) {
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "-min_pi":
                    minPi = Integer.parseInt(args[++i]);
                    break;
                case "-max_pi":
                    maxPi = Integer.parseInt(args[++i]);
                    break;
                case "-max_f":
                    maxPerFam = Integer.parseInt(args[++i]);
                    break;
                case "-min_f":
                    minPerFam = Integer.parseInt(args[++i]);
                    break;
                case "-t":
                    totalSeqs = Integer.parseInt(args[++i]);
                    break;
                case "-o":
                    updateOutputPath(args[++i]);
                    break;
                case "-v":
                    verbose = true;
                    break;
                case "-i":
                    updateInputPath(args[++i]);
                    break;
                default:
                    System.out.println("Unrecognized argument: " + args[i]);
            }
        }
    }

    private void updateOutputPath(String path) {
        outPath = path;
        outFile = new File(outPath);
        mafFolder = new File(outPath, "Maf_folder");
        clustal = new File(outPath, "ClustalFiles");
        if (!outFile.exists()) {
            boolean created = outFile.mkdirs();
            if (!created) {
                System.err.println("Failed to create output directory: " + outPath);
            }
        }
        if (!mafFolder.exists() && !mafFolder.mkdirs()) {
            System.err.println("Failed to create MAF folder within output directory.");
        }
    }

    private void updateInputPath(String path) {
        dbPath = path;
        File dir = new File(dbPath);
        if (!dir.exists() || !dir.isDirectory()) {
            System.err.println("Input directory does not exist or is not a directory: " + dbPath);
        }
    }
    @SuppressWarnings("resource")
    public static Map<String, String> realignSequences(String nameOfFile) throws IOException, InterruptedException {
        Map<String, String> mafftRealigned = new HashMap<>();
        // List to store command for ProcessBuilder
        List<String> command = new ArrayList<>();

        // Determine the MAFFT binary path safely
        Path mafftBinaryPath = Files.walk(Paths.get("/home/vandalovejoy/bin/"), 1)  // Adjust the path as necessary
                .filter(Files::isExecutable)
                .filter(p -> p.getFileName().toString().equals("mafft-ginsi"))
                .findFirst()
                .orElseThrow(() -> new IOException("MAFFT binary not found."));

        // Prepare the command
        command.add(mafftBinaryPath.toString());
        command.add("--quiet");
        command.add(nameOfFile);

        // Start the MAFFT process
        ProcessBuilder pb = new ProcessBuilder(command);
        Process mafftProcess = pb.start();

        // Read the output of the MAFFT process
        try (BufferedReader reAligned = new BufferedReader(new InputStreamReader(mafftProcess.getInputStream()))) {
            StringBuilder sequence = new StringBuilder();
            String speciesReal = "";
            String line;

            while ((line = reAligned.readLine()) != null) {
                if (line.startsWith(">")) {
                    // Save the previous sequence before starting a new one
                    if (!speciesReal.isEmpty()) {
                        mafftRealigned.put(speciesReal, sequence.toString().toUpperCase());
                        sequence = new StringBuilder();  // Reset sequence for the next block
                    }
                    speciesReal = line.substring(1);  // Remove ">" and save the species name
                } else {
                    sequence.append(line);
                }
            }
            // Don't forget to add the last sequence after exiting the loop
            if (!speciesReal.isEmpty()) {
                mafftRealigned.put(speciesReal, sequence.toString().toUpperCase());
            }
        }

        // Check the exit code of the process
        int exitCode = mafftProcess.waitFor();
        if (exitCode != 0) {
            throw new IOException("MAFFT exited with error code: " + exitCode);
        }

        return mafftRealigned;
    }

    public static void generateClustalFiles(Map<String, List<String[]>> rfamFamilies, File clustal) throws IOException {
        // Ensure the output directory exists
        Path outputPath = Paths.get(String.valueOf(clustal));
        if (!Files.exists(outputPath)) {
            Files.createDirectories(outputPath);
        }

        // Iterate through each RFam family in the map
        for (Map.Entry<String, List<String[]>> entry : rfamFamilies.entrySet()) {
            String rfamId = entry.getKey();
            List<String[]> sequences = entry.getValue();
            Path file = outputPath.resolve(rfamId + ".clustal");

            // Open a BufferedWriter to write to the Clustal file
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(file.toFile()))) {
                // Write the header (optional, depending on your needs)
                writer.write("CLUSTAL W multiple sequence alignment\n\n");

                // Write each sequence
                for (String[] sequenceData : sequences) {
                    String sequence = sequenceData[0].replace('U', 'T'); // Replace 'U' with 'T'
                    String sequenceName = sequenceData[1];
                    // Format and write the sequence to the file
                    writer.write(sequenceName + "    " + sequence + "\n");
                }
            } catch (IOException e) {
                System.err.println("Failed to write Clustal file for RFam ID " + rfamId);
                e.printStackTrace();
                // Handle exception or rethrow as needed
            }
        }
    }


}
